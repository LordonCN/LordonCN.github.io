---
layout: post
title: "[小冬撸代码]"
subtitle: '总结CPP经验'
author: "Lordon"
header-img: img/jassica/jessica-jung-celebrity.jpg
catalog: true
tags:
  - [小冬撸代码]
---
# 0、关于本文
半年没更新博客，细细想来过得是真快，马上就开始找工作了，这一部分就放cpp学习过程中自己积累的易错易混知识点。

###### 1、const的使用
- 加载函数最后
```c++
    // the variable is constant and prevent to modifying it 
    // it's a way to replace the #define
    const int i = 5;

    // 声明常量成员函数 const在声明和定义中都要使用
    // 获取当前id 不做修改
    int  getId() const {return id;};

    // ※定义常量指针 地址不可修改 所指向的数值可以修改
    int value_1 = 0;
    int*const intValuePtr_1= &value_1;
    *intValuePtr_1 = 10;
    cout<<intValuePtr_1<<" "<<value_1<<" "<<&value_1<<endl;
    
    // ※定义常量数值指针 地址可修改 所指向的数值不可以修改
    int value_2 = 10;
    int value_22 = 11;
    const int* intValueptr_2  = &value_2;
    intValueptr_2 = &value_22;
    
```


###### 2、添加enum 内联 条件运算符进行状态切换
- enum 
```c++
    state.h
      // 这里可以加当前是否允许攻击
      enum {attack,noattack};
      int state;
      void setAttackMode(){state = (state==attack)?noattack:attac};
```
    

###### 3、添加vactor容器(keyword:vector class)
- 创建容器
```c++
    Agents.h
        // 创建智能指针类型容器
        std::vector<std::shared_ptr<AgentAbstract>> all_agents;
        // 创建类指针容器
        std::vector<AgentAbstract*> ally;
        // 创建int容器
        std::vector<int> intCounter;
        vector<int*> intPointer;
        vector<string> stringList;
        vector<shared_ptr<int>> sharePtr;
```


###### 4、添加智能指针(keyword:smart ptr)
- 方法一： 类中声明，作用域在类全局 在构造函数中初始化
```c++
game.h:
	std::shared_ptr<Agents> agents; // 先声明
	
game.cpp
        agents.reset(new Agents(policyChoice)); // TODO:智能指针声明后初始化

```
- 方法二：直接初始化完毕
``` c++
agents.cpp
        std::shared_ptr<DPPolicyAgent> DPPointer(new DPPolicyAgent);
```
- 测试程序
``` c++
#include <iostream>
#include <memory>

using namespace std;

void intFunctionTest(shared_ptr<int>(pointer) )
{
   *pointer = 10;
}

void doubleFunctionTest(shared_ptr<double>(pointer) )
{
    *pointer = 10.12;
}

shared_ptr<int> intFunctionReturn(shared_ptr<int>(pointer))
{
   return pointer;
}

// 这一部分在game project中应用了 并且已更新在readme.md中
int main()
{
    // way1
    shared_ptr<int> pointerInt (new int);
    // way2
    shared_ptr<double> pointerDouble;
    pointerDouble.reset(new double);

    intFunctionTest(pointerInt);
    doubleFunctionTest(pointerDouble);

    cout<<"address of heaps is dynamic: "<<pointerInt<<endl;
    cout<<"address of stack is static: "<<&pointerInt<<endl;
    cout<<"value is: "<<*pointerInt<<endl;

    cout<<"address of heaps is dynamic: "<<pointerDouble<<endl;
    cout<<"address of stack is static: "<<&pointerDouble<<endl;
    cout<<"value is: "<<*pointerDouble<<endl;

    // 两个指针都指向同一块内容
    shared_ptr<int> pointerInt_r (new int);
    pointerInt_r = intFunctionReturn(pointerInt);

    cout<<"address of heaps is dynamic: "<<pointerInt_r<<endl;
    cout<<"address of stack is static: "<<&pointerInt_r<<endl;
    cout<<"value is: "<<*pointerInt_r<<endl;


    return 0;
}
```



###### 5、stl-sort的使用(不能在原数组调整)
- 在 include <algorithm> 中
<br>`本质`是对从选择范围内的所有数值进行`两两比较`后排序
<br>基本用法：
  
```c++
    // 从小到大默认排序 可以用于数组 vector 给好起止就好
    sort(nums.begin(),nums.end());
    // 若要从大到小排序 需要配合下面的函数进行修改 同时也可以用于二维数组
    sort(nums.begin(),nums.end(),sortCmp);
    
    // lambda
    sort(nums.begin(),nums.end(),[](int a,int b){return a>b});
```
<br>当前适用情况：
```c++
    // 二维数组按照其中某一维度排序 56
    bool sortCmp(const vector<int>&a,const vector<int>&b)
    {
        return a[0] < b[0]; // 升序 < 降序
    }
    // 数值大小排序 215
    bool sortCmp(int a,int b)
    {
        return a < b; // 升序 < 降序
    }
    // 按照字符串大小排序
    // 数值逐位排序 179
    bool sortCmp(int a,int b)
    {
        return to_string(a) < to_string(b); 
    }
```

###### 6、reverse-vector内容翻转的使用
-  include `<vector>`
-  include `<algorithm>` 
```c++
    // 对于vector类型的数据reverse很好用
    // 对于顺序有比较高要求的情况来说很好用
    reverse(smallNumber.begin(),smallNumber.end());
```

###### 7、accumulate-vector中元素求和的使用
- include `<numeric>`
- include `<vector>`

```c++
    vector<int>a;
    int aSum = accumulate(a.begin(),a.end(),0);
```


###### 8、erase-vector-map-set清空的使用
-  include `<vector>`
-  include `<unordered_map>`
-  include `<unordered_set>`
-  include `<set>`

```c++
    hashmap.erase(hashmap.begin(),hashmap.end());
    vector.erase(hashmap.begin(),hashmap.end());
    hashset.erase(hashmap.begin(),hashmap.end());
    
    unordered_set<int> hashSet(nums.begin(),nums.end());
    set<int> Set(nums.begin(),nums.end());
```



###### 9、new and delete的使用
[new 分两种]
- new：class中private定义的指针类型的变量
```c++
    State::State(){
    slocation = new float[2];
} 
    State::~State(){
    delete []slocation;
}
```
- new：使用过程中new出来的对象
```c++
    State *s = new State[2];

    // 作用域结束时要手动删除
    // 此处会调用两次State析构函数
    // 删除对象s构造函数中new出来的slocation
    delete []s;
```

###### 10、templatet只作用在一个函数上时的使用方法
-  <Utils.h> 中
```c++
    // .h 中class 声明:
    template<typename T1,typename T2>
    static float calculateDistance(const T1 (&pos1)[2], const T2 (&pos2)[2]);

    // .h 中函数定义 关键
    template <typename T1,typename T2>
    float Utils::calculateDistance(const T1 (&pos1)[2],const T2 (&pos2)[2]){
    float diff[2];
    diff[0] = static_cast<float>(pos1[0] - pos2[0]);
    diff[1] = static_cast<float>(pos1[1] - pos2[1]);
    float dist = sqrt(pow(diff[0]*100.6, 2) + pow(diff[1]*111, 2));
    return dist;
    };

```
update

